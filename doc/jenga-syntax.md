
# Syntax of Jenga configuration files

Jenga's config files are named `build.jenga` and have the following syntax.

Meta-notation: uppercase for lexical items; lower case for grammatical items; double quoted strings for literal keywords and symbols. Alternation is marked using pipe (`|`). Repetition is marked as `{...}*` for zero or more items, or `{...}+` for one or more items.

See [MakeStyle.hs](../src/MakeStyle.hs)
for the actual grammar implementation `gram :: Par [Clause]`
as well as the semantic processing function `elaborate :: Key -> G ()`.


## Lexical

A build _key_ is written as sequence of non white-space or special characters.
It refers to a source file or a file created as the target of a build rule.

White-space is used to separate lists of target and dependency keys.
Comments are shell-style: Everything from a hash character to the end of line is ignored.

```
KEY = [^\n @:#()]+

WHITESPACE = " "+

COMMENT-TO-EOL = "#" TEXT-TO-EOL

TEXT-TO-EOL = [^\n]+
```

## Grammar

A `build.jenga` file is made up of a sequence of clauses, each clause being a rule or an include declaration.

A _rule_ is the classic make-style triple composed of targets, dependencies and action.
There are two syntaxes for a rule: _classic-style_ where the action is written on an indented subsequent line; _oneline-style_ where the action is separated from the dependencies by a second colon.
An include declaration causes the named key file to be read and parsed for more clauses. The key may be a source file or generated by running a build action. This is how dynamic rule generation is expressed.

A _target_ is just a build key. A _dependency_ is either a build key or a _scanner_ dependency marked with the `@` syntax.
A rule has at least one target, but is allowed to have zero dependencies.
A scanner dependency causes the rule being defined to depend on the given key, plus more keys contained in the named key file, which may be source or generated. This is how dynamic dependencies are expressed.

```
file = {clause}*

clause = rule | "include" KEY

rule = rule-classic-style | rule-oneline-style

rule-classic-style =
  {target}+ ":" {dependency}* "\n" " "+ TEXT-TO-EOL

rule-oneline-style =
  {target}+ ":" {dependency}* ":" TEXT-TO-EOL

target = KEY

dependency = KEY | "@" KEY
```
